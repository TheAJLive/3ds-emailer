<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Discord Bot Client (3DS-safe)</title>
<style>
  body { margin:10px; background:#111; color:#eaeaea; font-family: Arial, sans-serif; }
  label { display:block; margin-top:8px; }
  input[type=text], textarea, select { width:100%; box-sizing:border-box; background:#1a1a1a; color:#eee; border:1px solid #333; padding:6px; }
  button { margin-top:8px; padding:6px 10px; background:#222; color:#eee; border:1px solid #444; }
  #messages { border:1px solid #333; height:380px; overflow-y:scroll; padding:6px; background:#0f0f0f; }
  .msg { border-bottom:1px solid #222; padding:6px 0; }
  .head { display:flex; align-items:center; gap:6px; }
  .pfp { width:28px; height:28px; border-radius:50%; background:#333; }
  .name { font-weight:bold; color:#fff; }
  .time { color:#aaa; font-size:12px; }
  .content { margin-top:2px; white-space:pre-wrap; color:#e0e0e0; }
  img.attachment { max-width:100%; display:block; margin-top:4px; }
  .row { margin-top:8px; }
</style>
</head>
<body>

<!-- CONFIG -->
<script>
  var WORKER_URL_DEFAULT = "https://YOUR-WORKER.workers.dev/"; /* <-- set this */
  var PAGE_PASSWORD = "3DS"; /* must match Worker SHARED_KEY */
  var AUTO_REFRESH_MS = 4000; /* poll interval */
</script>

<script>
(function(){
  var pass = prompt("Enter password:");
  if(pass !== PAGE_PASSWORD){ document.write("Access denied."); throw new Error("wrong password"); }
})();
</script>

<h2>Discord Bot Client</h2>

<label>Worker URL
  <input id="worker" type="text" placeholder="https://your-worker.workers.dev">
</label>

<label>Server (Guild)
  <select id="guild"></select>
</label>

<label>Channel
  <select id="channel"></select>
</label>

<label>Message
  <textarea id="content" rows="3" placeholder="Type..."></textarea>
</label>

<label>Image (single)
  <input id="file" type="file" accept="image/*">
</label>

<div class="row">
  <button id="sendBtn">Send</button>
  <button id="refreshBtn">Refresh</button>
</div>

<h3>Messages</h3>
<div id="messages"></div>

<script>
(function(){
  var $ = function(id){ return document.getElementById(id); };
  var worker = $('worker'), guildSel = $('guild'), channelSel = $('channel');
  var content = $('content'), file = $('file');
  var sendBtn = $('sendBtn'), refreshBtn = $('refreshBtn');
  var messages = $('messages');

  // state for incremental updates
  var lastMessageId = null;    // newest seen message id (Snowflake)
  var pollTimer = null;
  var isRefreshing = false;

  worker.value = WORKER_URL_DEFAULT || "";

  function esc(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function isoToLocal(ts){
    try{ var d=new Date(ts); var y=d.getFullYear(), m=('0'+(d.getMonth()+1)).slice(-2), day=('0'+d.getDate()).slice(-2);
      var hh=('0'+d.getHours()).slice(-2), mm=('0'+d.getMinutes()).slice(-2); return y+'-'+m+'-'+day+' '+hh+':'+mm;
    }catch(e){ return ts||''; }
  }
  function xhrGET(url, cb){
    var x=new XMLHttpRequest(); x.open('GET', url, true);
    x.setRequestHeader('X-Key', PAGE_PASSWORD);
    x.onreadystatechange=function(){ if(x.readyState===4){ cb(x.status, x.responseText); } };
    x.send();
  }
  function xhrPOST(url, form, cb){
    var x=new XMLHttpRequest(); x.open('POST', url, true);
    x.setRequestHeader('X-Key', PAGE_PASSWORD);
    x.onreadystatechange=function(){ if(x.readyState===4){ cb(x.status, x.responseText); } };
    x.send(form);
  }

  function renderAll(list){
    messages.innerHTML = '';
    for (var i=0;i<list.length;i++) addOne(list[i], true);
  }
  function addOne(m, appendToEnd){
    var div = document.createElement('div'); div.className='msg';

    var head = document.createElement('div'); head.className='head';
    var img = document.createElement('img'); img.className='pfp'; img.src = m.avatar_url || '';
    head.appendChild(img);

    var name = document.createElement('span'); name.className='name';
    var shown = m.display_name || m.username || 'user';
    name.textContent = shown;
    if (m.role_color) name.style.color = m.role_color;
    head.appendChild(name);

    var time = document.createElement('span'); time.className='time';
    time.textContent = ' Â· ' + isoToLocal(m.timestamp);
    head.appendChild(time);

    var body = document.createElement('div'); body.className='content';
    body.innerHTML = esc(m.content || '');

    div.appendChild(head);
    div.appendChild(body);

    if (m.attachments && m.attachments.length){
      for (var j=0;j<m.attachments.length;j++){
        var a=m.attachments[j];
        if (a.url && /\.(png|jpg|jpeg|gif|webp)$/i.test(a.url)){
          var im = document.createElement('img');
          im.src = a.url; im.alt='attachment';
          im.className='attachment';
          div.appendChild(im);
        }
      }
    }

    if (appendToEnd) messages.appendChild(div); else messages.insertBefore(div, messages.firstChild);
  }

  function loadGuilds(){
    var w = worker.value.trim(); if(!w){ alert('Set Worker URL'); return; }
    xhrGET(w+'?mode=guilds', function(st, txt){
      if(st>=200 && st<300){
        var arr=[]; try{ arr = JSON.parse(txt)||[]; }catch(e){}
        guildSel.innerHTML='';
        for (var i=0;i<arr.length;i++){
          var opt=document.createElement('option'); opt.value=arr[i].id; opt.text=arr[i].name; guildSel.appendChild(opt);
        }
        loadChannels();
      } else { alert('Failed to load servers: '+st+' '+(txt||'')); }
    });
  }

  function loadChannels(){
    lastMessageId = null;
    var w=worker.value.trim(), gid=guildSel.value; if(!w||!gid){ return; }
    xhrGET(w+'?mode=channels&guild_id='+encodeURIComponent(gid), function(st, txt){
      if(st>=200 && st<300){
        var arr=[]; try{ arr = JSON.parse(txt)||[]; }catch(e){}
        channelSel.innerHTML='';
        for (var i=0;i<arr.length;i++){
          var opt=document.createElement('option'); opt.value=arr[i].id; opt.text=arr[i].name; channelSel.appendChild(opt);
        }
        startPolling(); // will do initial full refresh
      } else { alert('Failed to load channels: '+st+' '+(txt||'')); }
    });
  }

  function fullRefresh(cb){
    if (isRefreshing) return; isRefreshing = true;
    var w=worker.value.trim(), ch=channelSel.value; if(!w||!ch){ isRefreshing=false; return; }
    xhrGET(w+'?mode=history&channel_id='+encodeURIComponent(ch), function(st, txt){
      isRefreshing = false;
      if(st>=200&&st<300){
        var data=[]; try{ data=JSON.parse(txt)||[]; }catch(e){}
        // Discord returns newest first; keep that
        renderAll(data);
        if (data && data.length) lastMessageId = data[0].id; // newest
        if (cb) cb();
      }
    });
  }

  function incrementalRefresh(){
    if (isRefreshing) return; isRefreshing = true;
    var w=worker.value.trim(), ch=channelSel.value; if(!w||!ch){ isRefreshing=false; return; }
    var url = w+'?mode=history&channel_id='+encodeURIComponent(ch);
    if (lastMessageId) url += '&after='+encodeURIComponent(lastMessageId);
    xhrGET(url, function(st, txt){
      isRefreshing = false;
      if(st>=200&&st<300){
        var data=[]; try{ data=JSON.parse(txt)||[]; }catch(e){}
        if (data && data.length){
          // API returns newest first; we want to prepend from newest->oldest so newest stays on top
          for (var i=0;i<data.length;i++){
            addOne(data[i], false);
          }
          lastMessageId = data[0].id;
        }
      }
    });
  }

  function startPolling(){
    if (pollTimer) { clearInterval(pollTimer); pollTimer=null; }
    fullRefresh(function(){
      pollTimer = setInterval(incrementalRefresh, AUTO_REFRESH_MS);
    });
  }

  function send(){
    var w=worker.value.trim(), ch=channelSel.value; if(!w||!ch){ alert('Choose server and channel'); return; }
    var form=new FormData(); form.append('mode','send'); form.append('channel_id', ch); form.append('content', content.value||'');
    if (file.files && file.files[0]) form.append('file', file.files[0], file.files[0].name||'image');
    xhrPOST(w, form, function(){
      file.value=''; content.value='';
      // instant refresh right after send
      incrementalRefresh();
    });
  }

  guildSel.onchange = loadChannels;
  channelSel.onchange = startPolling;
  sendBtn.onclick = send;
  refreshBtn.onclick = fullRefresh;

  loadGuilds();
})();
</script>
</body>
</html>
